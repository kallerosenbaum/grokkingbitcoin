[[ch09]]
== Transactions revisited - Bells and whistles
:imagedir: {baseimagedir}/ch09

This chapter covers

* Making transactions invalid until a certain time
* Attaching arbitrary data to transactions
* Swapping coins between different blockchains
* Streaming money

We are now past the core chapters of the book in which you have
learned the basics of Bitcoin. In this chapter we will dig deeper into
what functionality transactions can offer us.

We will start by exploring the lock time and sequence numbers of
transactions. Lock time is a way to make transactions invalid until a
certain point time, or a certain block height. This means that you can
create a transaction that can not be included in a block until that
block height or point in time has passed. This is useful for a lot of
more advanced features like payment channels and atomic swaps covered
later in this chapter.

Sometimes it's useful to store some small amount of data in a
transaction in the blockchain. For example, a car manufacturer may
want to track ownership of a car by putting the chassis number of the
car into a Bitcoin transaction, effectively creating a token on the
Bitcoin blockchain. The current owner can then transfer ownership of
the car by sending that token to the new owner.

As mentioned in <<altcoins>>, there are a lot of alternative
cryptocurrencies. Sometimes you may want to trade for example
namecoins for bitcoins. The most obvious way to do it is to use an
exchange to sell bitcoin and buy namecoins, but there are other more
decentralized ways to do it. _Atomic swaps_ lets you swap your
bitcoins directly with someone holding namecoins without a trusted
third party like an exchange.

Lastly we will explore some intricate details of
signatures. Signatures can be made in different ways depending on your
use case. You can tune what the signature should commit to. In other
words, we can change how do the signing algorithm hashes the
transaction.

=== Time locked transactions

When you create and sign a transaction it will be valid and ready for
inclusion in any future block. You can broadcast it immediately and
have it mined. This is the normal case.

However, there are times when you want to sign a transaction but be
guaranteed not have it mined until after at least, say one year, have
passed.

Suppose that you have a fair amount of bitcoins, and in case you die,
you want your daughter to get the money to her address @~D~, but only
after you die. You can create a transaction that is time locked:

[.gbinfo]
.No fee?
****
For the sake of simplicity, this example don't pay any fees.
****

.A payment to your daughter that will become valid after one year has passed.
image::{imagedir}/timelock-to-daughter.svg[{half-width}]

[.gbinfo]
.Sequence numbers
****
The sequence numbers are always included in inputs, but we haven't
showed them because they didn't matter to the transactions we've used
so far.
****

What makes this transaction special are the sequence numbers of the
inputs and the transaction lock time. We briefly mentioned sequence
numbers in <<_lock_time_and_sequence_numbers>>. The sequence numbers
are used to "enable" the lock time: If any input has a sequence number
less than `ffffffff`, for example `fffffffe`, the lock time set on the
transaction will be effective. If all sequence numbers are `ffffffff`,
the lock time doesn't have any effect.

You give this transaction to your daughter. This transaction is
currently invalid, and your daughter stores it on her computer and she
even prints a backup that she keeps in another place. It is not
broadcast; No full node will accept a block containing this
transaction yet. The transaction will become valid in the morning of
2019-04-30. If you die before that, your daughter can wait until after
the lock time date and then claim the money by broadcasting the
transaction, which has then become valid.

If you don't die before that date, you want to make sure that the time
locked transaction becomes useless, so that your daughter can't take
the money once the time lock date has passed. One way to do that is to
spend one of the inputs of Tx~1~, to make the time locked transaction
forever invalid, and create a new time locked transaction for yet
another year:

.Make Tx~1~ invalid by spending an output that Tx~1~ spends and create a new time locked transaction to your daughter
image::{imagedir}/timelock-to-daughter-2.svg[{big-width}]

[.gbinfo]
.Transaction malleability
****
There is a problem here. The txid of Tx~2~ _can_ change while being
broadcast, making Tx~3~ forever invalid. That's fixed by _segregated
witness_ in <<ch10>>.
****

You need to

. Create and sign a transaction, Tx~2~, that spends at least one of
the inputs of Tx~1~. Tx~2~ is a normal, not time locked,
transaction. Don't broadcast this transaction just yet.
. Create a new time locked transaction, Tx~3~, that spends all your
valid outputs, given that Tx~2~ becomes mined and give Tx~3~ to your
daughter.
. Broadcast Tx~2~. Once mined, Tx~1~ will become forever invalid,
because one of the inputs of Tx~1~ is spent by Tx~2~.

Note how the order of events are important here. If Tx~2~ is
broadcasts _before_ you give Tx~3~ to your daughter, there's a chance
that you die before giving her the transaction. Then your daughter
will not be able to receive the funds, because she has no valid
transaction to claim them with. Tx~1~ is invalidated by Tx~2~ in the
blockchain, and Tx~3~ is not in your daughter's possession. Just do it
right, OK?

==== Time measurements

There are two ways to express a lock time in a transaction. The first
way is by setting a date and time as in the example above. The second
way is to set a block height.

===== Block time

In the example above the lock time was expressed as a date and
time. That actually means that the _median of the past 11 timestamps_
must be greater than the lock time in the transaction. Remember the
rules for the block timestamps in <<timestamp-rules>>? We said then
that a timestamp of a block must be greater than the past 11 block
median timestamp. We use that same median to decide whether a
transaction is valid with regards to lock time. Suppose that you've
died on 2019-01-24. Your mourning daughter can't claim your money
until 2019-04-20. More precisely:

.Your daughter may claim your money after the median of the past 11 blocks is earlier than your lock time.
image::{imagedir}/locktime-rules.svg[{full-width}]

Your daughter's transaction cannot be mined in any block before the
last one in the figure above. The median of the past 11 blocks, is
strictly increasing according to the rules in
<<timestamp-rules>>. It's not until the block _after_ the one with
timestamp 07:33:21 that she can get her transaction confirmed. Before
that block, the median past time is too early.

Her transaction will not even propagate through the Bitcoin network
until the lock time has passed. The nodes don't want to keep time
locked transactions in their memories because they think there are
better uses for the precious memory space than to fill them up with
transactions that aren't even valid (yet). It's up to your daughter to
broadcast the transaction after the lock time has passed.

===== Block height

There is another way to express time: By using block height. You can
say that a transaction is not valid until after block height
571019. Miners can not include the transaction:

.A time locked transaction based on block height. This transaction is first valid at block height 571020.
image::{imagedir}/height-timelock-to-daughter.svg[{half-width}]

until after block 571019 has been mined. The earliest block that the
transaction can be included in is at height 571020. It's hard to
predict exactly when that block will be mined, but thanks to the
difficulty adjustments that keeps the average block time at about 10
minutes, you can expect about 52596 per year.

=== Time locked outputs

Time locks are not very useful in itself. The only thing you can use
it for is to create a transaction that may eventually become valid.

You may instead want to say something like "The money in this output
are not allowed to be spent before new years eve.", or "The money in
this output must not be spent before 300 blocks have been mined on top
of the block containing this output". These are examples time locked
outputs. An output can be locked by

* absolute time or block height
* relative time or number of blocks after the block containing the output

==== Absolute time locked outputs

[.inbitcoin]
.BIP65
****
This BIP describes in detail the Script operator,
OP_CHECKLOCKTIMEVERIFY, that implements the absolute time locked
output.
****

Suppose that you want to give your daughter 1 BTC allowance on the
first of May. You can then make a transaction as follows:

.Paying allowance in advance to your daughter. She may not spend it before may 1 2019.
image::{imagedir}/absolute-time-locked-outputs.svg[{half-width}]

You can broadcast this transaction immediately to the Bitcoin network
and have it mined. The first output is the interesting part. It says
that this output cannot be spent before May 1 (2019). For the curious,
the exact scriptPubKey is:

[subs="normal"]
----
<may 1 2019 00:00:00> OP_CHECKLOCKTIMEVERIFY OP_DROP
OP_DUP OP_HASH160 <PKH~D~> OP_EQUALVERIFY 
OP_CHECKSIG
----

This script will make sure that the transaction spending the output is
sufficiently time locked. For example

.Various spending transactions and their validity.
image::{imagedir}/absolute-time-locked-outputs-spending.svg[{big-width}]

The first two transactions will never be valid because their time
locks are not sufficiently late. The first one is not locked at all,
which is illegal according to the scriptPubKey. The other one is at
least time locked, but it's not late enough. 1 second before May 1 is
too early.

The third transaction on the other hand is OK, because the time lock
is at least as high as the time in the scriptPubKey, 2019-05-01
00:00:00. So this transaction will be valid on and after May 1. The
last transaction will be valid on new year's eve right before the
fireworks. Note however that both of the two last transactions cannot
be mined, at most one of them can be mined since they spend the same
outputs.

The result of this example is that your daughter will be able to spend
the output as she pleases after May 1.

==== Relative time locked outputs

[.inbitcoin]
.BIP68 and BIP112
****
These two BIPs describe relative time locked outputs. The script
operator is called OP_CHECKSEQUENCEVERIFY.
****
A relative time locked output works similar to absolute time locked
outputs, but relative locks requires that a certain amount of time has
passed between the block containing the output and the block
containing the spending transaction.

.Spending a relative time locked output is allowed after a certain amount of blocks has passed.
image::{imagedir}/relative-lock-overview.svg[{half-width}]

Relative time locks are most commonly used in _digital contracts_. A
digital contract can be regarded as a traditional contract between
parties, but they are enforced by the rules of the Bitcoin network
rather than national laws. Contracts are expressed as Bitcoin
transaction output scripts, the scriptPubKey. We will illustrate the
use of relative time locked outputs with an _atomic swap_ in the next
subsection. An atomic swap means that two persons swap coins with
each other across different cryptocurrencies.

==== Atomic swaps

A commonly mentioned digital contract is the _atomic swap_, where two
parties want to swap coins with each other between different
blockchains.

Suppose that John is chatting with Fadime on a public forum on the
Internet. They don't know each other and have no reason to trust one
another. But they both want to trade.

.Atomic
****
In compute science, the word _atomic_ means that a process either
completes in its entirety or not at all. For atomic swaps it means
that either the swap completes or they both get to keep their old
coins. There are no other possible outcomes.
****

They agree that John will trade 2 bitcoins for 100 of Fadime's
namecoins (NMC). Namecoin is an altcoin used as a decentralized naming
system, like DNS. We talked briefly about altcoins in <<ch01>>. It's
not important what Namecoin actually is used for in this example; We
only conclude that it's another cryptocurrency on another blockchain
than Bitcoin's.

The conversation started like this:

.John:
> Do you want to swap 100 NMC for my 2 BTC? My Namecoin public
> key is
> 02381EFD...88CA7F23. I've
> created a secret random number that has the SHA256 hash value H. I
> will not tell you the secret number yet.

.Fadime:
> Sure John, letâ€™s do it! My Bitcoin public key is
> 02b0c907...df854ee8

****
image::{imagedir}/2ndcol-s-and-h.svg[]
****

We will call the secret number S. Only John knows S for now, but he
shares the hash of S, H, with Fadime. Now they both have enough
information to get started.

They create one transaction each. John creates a Bitcoin transaction
that spends 2 of his BTC. Fadime creates a Namecoin transaction that
spends 100 of her NMC. They don't broadcast their transactions yet.

image::{imagedir}/atomic-swaps-1.svg[{big-width}]

The output of John's contract transaction can be spent in one of two
ways:

1. By providing the pre-image of H, and Fadime's signature. John knows
such a pre-image, namely his secret number S from the conversation
above, but Fadime doesn't.
2. With John's signature after 48 hours.

Likewise, the output of Fadime's contract transaction can be spent in
one of two ways:

1. By providing the pre-image of H, and John's signature.
2. With Fadime's signature after 24 hours.

The relative lock time is enforced by the Script operator
`OP_CHECKSEQUENCEVERIFY`. This operator requires that the output of
John's contract transaction is not spent until 48 hours has passed
from the time when the contract transaction was confirmed. In Fadime's
contract transaction, the operator requires that the output is unspent
for at least 24 hours.

Fadime knows that John has the secret number. So if Fadime broadcasts
her contract transaction now, John can take the money and not fulfill
his part of the deal. For this reason she will not broadcast her
transaction until she has seen John's transaction safely confirmed in
the blockchain. Since Fadime don't know the secret, S, John can safely
broadcast his contract transaction without Fadime running away with
the money.

.p2sh address creation
****
image::{imagedir}/2ndcol-p2sh-address-creation.svg[]
****

So John broadcasts his contract transaction. Remember that the output
of the contract transactions in this example are pay-to-script-hash,
p2sh, outputs. The output contains a p2sh address that doesn't say
anything about this being John's contract output. So, in order for
Fadime to identify John's contract transaction on the blockchain, she
will construct the same redeem script as John created for his contract
transaction and generate the p2sh address John's contract transaction
paid to. Then she can look for that p2sh address in the blockchain.

When Fadime finds that John's transaction is confirmed, she broadcasts
her own contract transaction. John waits until Fadime's transaction is
sufficiently confirmed on the Namecoin blockchain. Then the actual
swap happens in two steps:

.The first step of the actual swap. John claims Fadime's 100 NMC by revealing the secret S.
image::{imagedir}/atomic-swaps-2.svg[{big-width}]

John broadcasts his swap transaction. John's swap transaction spends
Fadime's contract transaction output by providing S and his
signature. Again, note that John is spending a p2sh output, which
means that the first thing that happens is that the redeem script that
John provided in the scriptSig, will be hashed and compared to the
hash in the scriptPubKey. Then the actual redeem script will be run.

We won't go through the program in detail. But when the redeem script
starts running, the stack will have "1" on top. This means "true" in
Namecoin, just as in Bitcoin. That value will cause the program to run
the part of the script that requires a pre-image and John's
signature. The other part is not run at all.

The script will leave the stack with a true on top because John
provides both required items in the correct order, his signature and
the pre-image, `S`. He successfully claims his 100 NMC.

Now, as soon as Fadime sees John's swap transaction she can create her
own swap transaction on the Bitcoin blockchain.

.Fadime completes the atomic swap by sending her swap transaction to the Bitcoin network.
image::{imagedir}/atomic-swaps-3.svg[{big-width}]

She takes the secret pre-image, S, from John's swap transaction and
puts it into her own swap transaction that pays 2 BTC to Fadime's
public key hash, PKH~F~. When the two swap transactions get confirmed,
the atomic swap is complete. The effect of all this is that John has
sent 2 BTC to Fadime, under the condition that Fadime sends 100 NMC to
him, and Fadime sends 100 NMC to John under the condition that John
sends 2 BTC to her.

===== Failure of atomic swap

The sequence of events in the atomic swap example above illustrated
the case where both parties, John and Fadime, played by the rules. No
one had to actually use the time locked branches of the contract
transaction outputs. This subsection will go through some ways that
the swap might fail.

Fadime doesn't broadcast her contract transaction:: This means that
John can't spend the output of Fadime's contract transaction, which
means that Fadime will never get to see S. Without S, she can't spend
John's contract output. The only possible outcome is that John must
wait 48 hours for the relative time lock to release and then reclaim
his own money.

John doesn't spend Fadime's contract output in 24 hours:: Fadime can
reclaim her coins and John must wait another 24 hours before claiming
his coins back.

John spends Fadime's contract output just after 24 hours has passed but before Fadime claims back her coins::
Thankfully John's contract output has a 48 hour relative lock time as
opposed to 24 hours in Fadime's contract output, so John can't claim
his coins back until he has waited another 24 hours. During this time,
Fadime can claim her BTC from John's contract output at any time using
S and her signature.

Fadime gets hit by a bus just after broadcasting her contract output::
This is no good. John will be able to take his NMC from Fadime's
contract output and then wait 48 hours to also claim back
his BTC. Fadime loses out on this one.

In the last of these cases, one could argue that the swap wasn't
atomic. After all, the swap didn't go through and John ended up with
all coins. This is a somewhat philosophical question. But we can think
of swaps as being atomic under the condition that Fadime is able to
take actions. We don't have this condition for John, though. It's a
matter of who creates the secret, S.

=== Storing stuff in the Bitcoin blockchain

In the early days of Bitcoin, it became clear that people wanted to
put stuff in transactions in the Bitcoin blockchain that doesn't have
anything to do with Bitcoin itself.

.A blockchain tribute to Cryptographer Sassama allegedly posted by Dan Kaminsky. The message is wrapped into 3 columns to save space.
----
---BEGIN TRIBUTE---     LEN "rabbi" SASSAMA     P.S.  My apologies,
#./BitLen                    1980-2011          BitCoin people.  He
:::::::::::::::::::     Len was our friend.     also would have    
:::::::.::.::.:.:::     A brilliant mind,       LOL'd at BitCoin's 
:.: :.' ' ' ' ' : :     a kind soul, and        new dependency upon
:.:'' ,,xiW,"4x, ''     a devious schemer;         ASCII BERNANKE  
:  ,dWWWXXXXi,4WX,      husband to Meredith     :'::.:::::.:::.::.:
' dWWWXXX7"     `X,     brother to Calvin,      : :.: ' ' ' ' : :':
 lWWWXX7   __   _ X     son to Jim and          :.:     _.__    '.:
:WWWXX7 ,xXX7' "^^X     Dana Hartshorn,         :   _,^"   "^x,   :
lWWWX7, _.+,, _.+.,     coauthor and            '  x7'        `4,  
:WWW7,. `^"-" ,^-'      cofounder and            XX7            4XX
 WW",X:        X,       Shmoo and so much        XX              XX
 "7^^Xl.    _(_x7'      more.  We dedicate       Xl ,xxx,   ,xxx,XX
 l ( :X:       __ _     this silly hack to      ( ' _,+o, | ,o+,"  
 `. " XX  ,xxWWWWX7     Len, who would have      4   "-^' X "^-'" 7
  )X- "" 4X" .___.      found it absolutely      l,     ( ))     ,X
,W X     :Xi  _,,_      hilarious.               :Xx,_ ,xXXXxx,_,XX
WW X      4XiyXWWXd     --Dan Kaminsky,           4XXiX'-___-`XXXX'
"" ,,      4XWWWWXX     Travis Goodspeed           4XXi,_   _iXX7' 
, R7X,       "^447^                               , `4XXXXXXXXX^ _,
R, "4RXk,      _, ,                               Xx,  ""^^^XX7,xX 
TWk  "4RXXi,   X',x                             W,"4WWx,_ _,XxWWX7'
lTWk,  "4RRR7' 4 XH                             Xwi, "4WW7""4WW7',W
:lWWWk,  ^"     `4                              TXXWw, ^7 Xk 47 ,WH
::TTXWWi,_  Xll :..                             :TXXXWw,_ "), ,wWT:
=-=-=-=-=-=-=-=-=-=                             ::TTXXWWW lXl WWT: 
                                                ----END TRIBUTE----
----

While this was certainly funny, it has some implications for Bitcoin's
full nodes. This is purposefully ironic given the P.S. message that
refers to the centralizing effect an ever increasingly growing
blockchain will have due to increased cost of running a full node.

The above message was written into the blockchain using a single
transaction with transaction id
`930a2114cdaa86e1fac46d15c74e81c09eee1d4150ff9d48e76cb0697d8e1d72`. The
author created a transaction with 78 outputs, one for each 20
character line in the message. Each line ends with a space so only 19
characters are visible.

For example, the very last output's scriptPubKey looks like this:

 OP_DUP OP_HASH160 2d2d2d2d454e4420545249425554452d2d2d2d20 OP_EQUALVERIFY OP_CHECKSIG

****
image::{imagedir}/2ndcol-pkh-creation.svg[]
****

The interesting part is the public key hash. This is not an actual
public key hash, but a made up one. Maybe you can see a pattern when
you compare it to the line `----END TRIBUTE---- `:

 2d 2d 2d 2d 45 4e 44 20 54 52 49 42 55 54 45 2d 2d 2d 2d 20
 -  -  -  -  E  N  D     T  R  I  B  U  T  E  -  -  -  -   

This "public key hash" encodes one 20 character line in the
message. It uses the so called _ASCII table__ to encode
characters. For example the character `-` is encoded as the byte
`2d`. The characters A-Z are encoded by the bytes `41`-`5a`, and space
is encoded as byte `20`.

Let's have a look at the public key hashes of the 10 last lines of the
message along with they ASCII-decoded text:

----
20203458586958272d5f5f5f2d60585858582720   4XXiX'-___-`XXXX'
202020345858692c5f2020205f69585837272020    4XXi,_   _iXX7'
20202c2060345858585858585858585e205f2c20   , `4XXXXXXXXX^ _,
202058782c202022225e5e5e5858372c78582020   Xx,  ""^^^XX7,xX
572c22345757782c5f205f2c5878575758372720 W,"4WWx,_ _,XxWWX7'
5877692c202234575737222234575737272c5720 Xwi, "4WW7""4WW7',W
54585857772c205e3720586b203437202c574820 TXXWw, ^7 Xk 47 ,WH
3a5458585857772c5f2022292c202c7757543a20 :TXXXWw,_ "), ,wWT:
3a3a54545858575757206c586c205757543a2020 ::TTXXWWW lXl WWT:
2d2d2d2d454e4420545249425554452d2d2d2d20 ----END TRIBUTE----
----

Most Bitcoin full nodes have (and had at the time of the above
transaction) a policy requiring that each output must have a
non-negligible value. If not, the transaction would simply be
dropped. There are some exceptions to this default policy that we'll
learn in a moment. Each of the outputs pays 0.01 BTC to a
bogus PKH to circumvent these policies.

==== Bloated UTXO set

Since these public key hashes are made up, there is no known pre-image
to them. This also means that there is no know public/private key pair
associated with the public key hashes. Thus, the outputs can never be
spent by anyone. They are _not spendable_. The Bitcoin address of the
last PKH is `157sXYpjvAyEJ6TdVFaVzmoETAQnHB6FGU`. Whoever pays money
to this address throws the money in the trash. The money is lost
forever. It is the equivalent of burning a dollar bill.

Not spendable outputs as the ones above are indistinguishable from
ordinary, spendable, outputs. They are _unprovably not
spendable_. Full nodes have to treat them as spendable, meaning that
they have to keep these not spendable outputs in their UTXO (unspent
transaction output) set.

As more and more not spendable outputs are created, the UTXO set will
grow. As the UTXO set grows, it will occupy more and more memory on
the full nodes.

The developers of Bitcoin came up with a partial solution to this
problem. Instead of sending money to unprovably not spendable outputs,
users can create _provably not spendable_ outputs. If a full node can
determine if an output is not spendable, it doesn't have to insert it
into its UTXO set.

The partial solution involves a new Script operator called
`OP_RETURN`. This operator immediately fails when executed. A typical
OP_RETURN scriptPubKey can look like this

 OP_RETURN "I'm beginning to grok Bitcoin"

If someone would try to spend this output, it would cause the script
to fail when it encounters the `OP_RETURN`. So if the scriptPubKey
contains this operator, a full node can determine that the output is
not spendable and simply ignore the output. Saving the UTXO set from
being forever bloated with this nonsense.

There are a few policies regarding OP_RETURN:

* The full scriptPubKey must not be bigger than 83 bytes
* There can only be one OP_RETURN output per transaction
* OP_RETURN output are allowed to have 0-value, so that you don't have
  to burn money to use it.

==== Create a token in Bitcoin

We talked briefly about tracking ownership on the blockchain in
<<ch01>>. Suppose that a car manufacturer, let's call them Ampere,
decides that they want to digitally track the ownership of their cars
on the Bitcoin blockchain. This can be accomplished by creating a
token in Bitcoin.

Suppose that the Ampere wants to create a token for a newly
manufactured car with the chassis number 123456. Then they broadcast a
Bitcoin transaction as follows:

.Ampere creates a new token for a newly built car. They issue the token to themselves because they still own this car.
image::{imagedir}/car-token-1.svg[{half-width}]

This "Ampere token protocol" depicts that a new token is created by

* Ampere spends a coin from PKH~A~
* The transaction contains an OP_RETURN output with the text `"ampere
  <chassis number>"`.
* The output immediately following the OP_RETURN output is the initial
  owner of the token.

Ampere has a well known web page at https://www.ampere.example.com/
where they have published their public key corresponding to
PKH~A~. They also pump out their public key through advertisements and
other means of communications. They do this so that people can verify
that PKH~A~ actually belongs to Ampere.

Now suppose that Ampere sells this car to a car dealer. The dealer has
a public key hash PKH~D~. This is how Ampere will transfer the digital
ownership to the dealer:

.Ampere sells the car to a car dealer with public key hash PKH~D~.
image::{imagedir}/car-token-2.svg[{big-width}]

According to our simple protocol, ownership of a car is transferred by
spending the old owner's output. The following rules apply:

* The spending transaction spends the old owner's output.
* The first output is the new owner of the car.
* The first output must have the same value as the old owner's output.

Now the car dealer is the new owner because the PKH~D~ is the first
output of the spending transaction. That's it. When the dealer sells
this car to a consumer, Fadime, the dealer transfers the ownership of
the car to Fadime's address, PKH~F~:

.The car dealer transfers the ownership of the car to Fadime's PKH~F~. 
image::{imagedir}/car-token-3.svg[{big-width}]

==== Start the car with proof of ownership

Now, that Fadime is the rightful owner of this car, wouldn't it be
cool if she could start the car by proving that she is the owner?
She can. The car is equipped with an ignition lock that starts the
engine when Fadime sends a proof of ownership to the car.

.Fadime starts her car by signing a challenge with her private key.
image::{imagedir}/car-token-4.svg[{half-width}]

Fadime first asks the car to start. The car will not start if it
doesn't know that Fadime has the private key belonging to PKH~F~. The
car generates a big random number and sends it to Fadime. Fadime signs
this random number with the private key and sends the signature and
her public key to the car.

The car needs the public key to be able to verify that the public key
corresponds to PKH~F~ as written in the blockchain. The car keeps
track of who currently owns the car by running a lightweight wallet
that understands the Ampere token protocol.

When the car has verified that the signature is valid and from the
correct private key it will start the engine.

=== Replace pending transactions

When you send a Bitcoin transaction to buy a book online, the book
store will wait for the transaction to confirm before it sends the
book to you. Usually your transaction will get confirmed within an
hour or so, but what if it doesn't? What if no miner ever wants to
include your transaction? This can certainly happen if your
transaction fee is not sufficient.

[id=stuck-transaction]
.You pay for your book and set the transaction fee to 0.0001 BTC
image::{imagedir}/rbf-1.svg[{half-width}]

You may recall from <<_transaction_fees>> that the transaction fee is
the sum of the input values minus the sum of the output values. The
fee per byte that miners care for is calculated by dividing that fee
with the size of the transaction. In this case 1000 satoshis divided
by 225 bytes, which is about 4.4 sat/byte.

If no miner is willing to include the transaction for that fee, your
transaction will be stuck waiting for confirmation. If the transaction
isn't confirmed, you will not get your book. You probably want to do
something about the situation. Maybe you can create a new similar
transaction, but with a higher fee? Let's try.

.You try to replace your old, stuck, transaction with a new one with higher fee.
image::{imagedir}/rbf-2.svg[{half-width}]

That's nice. You have created and signed a new transaction with a 20
times higher fee. This would surely get mined, you think, and
broadcast the transaction.

The problem is just that your new transaction will probably be
regarded as a double spend attempt and be dropped by most nodes. They
think that the first transaction is the one that counts and disregards
any further transactions that spend the same output. It is completely
up to the nodes how to handle the second transaction, but the most
common policy is to drop it. This is what Bitcoin Core does, and
that's the most widely used Bitcoin software. This policy is know as
the _first seen policy_.

You may be able to circumvent this policy by sending the second
transaction directly to one or more miners. Miners have different
incentives than full nodes. Miners want to earn bitcoins by providing
proof of work to the blockchain, while non-mining full nodes want to
keep their memory and computing resource consumption down. So if a
miner would get hold of the second, high-fee transaction, it would
probably decide to include that despite the fact that the low-fee
transaction was first seen. This way to replace transactions is very
impractical, because you don't know the IP address of any miners
unless they publish it somehow, you also reveal your IP address to the
miners, who then become targets for various surveillance organizations
or companies wanting to monetize information about you.

==== Opt-in replace by fee

[.inbitcoin]
.BIP125
****
This BIP describes how transactions can "declare" themselves as
replaceable. 
****

In 2016 a policy was deployed for transaction replacement. It's
generally called _replace by fee_, or RBF. It works by using the
_sequence numbers_ of the inputs of a transaction.

.Use opt-in replace by fee to be able to easily replace your transaction before it's confirmed.
image::{imagedir}/rbf-3.svg[{half-width}]

Suppose again that you want to pay for a book in an online book
store. When you create the transaction, you make sure that one of the
inputs (there is only one in this example) has a sequence number less
than `fffffffe`. This signals to nodes that you want this transaction
to be replaceable. Before BIP68, relative lock time, the sequence
numbers were unused. The intention with sequence numbers from the
beginning was to allow for replace-by-fee, but the feature was
disabled in the software. These sequence number have since been
re-purposed for absolute lock time, relative lock time, and replace by
fee as described throughout this chapter.

When a node receives this transaction, it will be treated as a normal
transaction but the replaceability will be remembered.

When you later notice that your transaction doesn't confirm because of
a too low fee, you can create a new, replacement transaction with a
higher fee. When you broadcast the replacement transaction, the nodes
receiving it will, if they implement the opt-in RBF policy, kindly
replace the old transaction with the new one and relay the new one to
it's peers. The old transaction will be dropped. This way, the
replacement transaction will eventually reach all nodes, including
miners, and hopefully this new replacement transaction will get
confirmed within reasonable time.

In the example above you set the sequence number of the input of the
replacement transaction to `ffffffff`. This has the effect that the
replacement transaction is not itself replaceable. If you want the
replacement transaction to be replaceable you need to set its sequence
number to `fffffffd` or less just as you did on the replaced
transaction.

==== Child pays for parent

There is yet another way to bump up a fee. Suppose that you have the
situation from <<stuck-transaction>>:

.You have not paid sufficient transaction fee. Transaction is stuck in pending state because miners don't want to include your transaction in a block.
image::{imagedir}/rbf-4.svg[{half-width}]

If you notice that this transaction is stuck, you can make another
transaction that spends your change and pays an extra high fee to
compensate for the low fee in your original transaction.

.Spend your change and pay extra fee for the "parent" transaction.
image::{imagedir}/rbf-5.svg[{big-width}]

Suppose that a miner sees these two transactions. If the miner wants
to collect the fee from the child transaction, it has to include both
the parent transaction and the child transaction. If it tries to
include only the child transaction, the block wouldn't be valid
because the child transaction spends money that don't exist in the
blockchain.

This trick can be performed both by you and by the book store. Suppose
that you don't bump the fee at all. Then the book store can spend its
output of 10 BTC and pay themselves 9.9998 BTC to in order add 0.0002
BTC to the combined fee.

=== Summary of sequence numbers

The sequence numbers of inputs are used for a variety of
purposes. This is because they were initially unused, which made them
a natural choice for introducing new functionality without having to
change the format of transactions.

We have discussed all different uses for sequence numbers in this
chapter, and it's hard to keep track of them. Let's summarize the meaning for different values of the sequence numbers:

.Sequence numbers are used to enable or disable various features.
|===
| Sequence value (descending order) | relative lock time (BIP68), per input | BIP125 (replace by fee), any input | locktime, any input

| `ffffffff` | Disabled | Disabled | Disabled
| `fffffffe` | Disabled | Disabled | Enabled
| `fffffffd` | Disabled | Enabled  | Enabled
| `80000000` | Disabled | Enabled  | Enabled
| `7fffffff` | Enabled  | Enabled  | Enabled
| `00000000` | Enabled  | Enabled  | Enabled
|===

=== Different signature types

When you sign a typical Bitcoin transaction you sign the entire
transaction excluding the scriptSig.

.Normally the whole transaction is signed. All inputs and all outputs are covered.
image::{imagedir}/sign-transaction-all.svg[{quart-width}]

This transaction contains two inputs and each input signs the complete
transaction. A signature _commits to_ all inputs and all outputs. If
any of the inputs or outputs change, the signature will become
invalid.

This behavior of signatures can be changed using a parameter in the
signature.

.A signature can commit to different parts of the transaction depending on the so called SIGHASH types. This illustrates what a signature in the second input would commit to for different combinations of SIGHASH types.
image::{imagedir}/sign-transaction-combos.svg[{half-width}]

There are three ways to commit to outputs and two ways to commit to
inputs. For the outputs, you can commit to

* all output (ALL). No one gets to change any outputs.
* a single output at the same index as the input (SINGLE). I only care
  about the specific output. The rest may change.
* no outputs (NONE). I don't care at all where the money goes. Anyone
  can add any outputs without invalidating my signature.

For the inputs you can commit to

* all inputs (ANYONECANPAY is not set). No one can change any input because my signature would become invalid.
* only the current input (ANYONECANPAY is set). Other inputs may be removed or added. I don't care who pays. Anyone can pay.

Any combination of a input SIGHASH type and output SIGHASH type can be
used which makes 6 different combinations as in the figure.

For the vast majority of signatures, ALL is used to commit to the
whole transaction. This is what we are used to from all the chapters
in this book. Other types are really rare, and used primarily for
specialized digital contracts.

==== Funding a skate park

As a simple example of how you can use the SIGHASH types, suppose that
you want to raise money to build a skate park in the area you
live. The skate park will cost 10 BTC to build. You can then send an
email to all families in your neighborhood:

----
Dear families,

I'm planning to build a skate park. If you want to help with funding
it, please send me a transaction with one input and one output as
follows:

Input: The amount of money you want to contribute to the project,
signed with SIGHASH types ANYONECANPAY and ALL. Note that you will not
get any change back. The whole input will go into funding of the skate
park

Output: 10 BTC to 1G5cycsCpe1ABLK41WTttnK1fo8ypYvocj

Regards
Susie
----

Your neighbors can now join the project by sending your transactions that you assemble into a single transaction once you have enough funding.

Let's say that you and 2 neighbors want to fund the skate park, then you will receive two transactions from your neighbors that you can assemble together with your own input:

.Three neighbors contribute to the funding of the skate park. They all send some bitcoin to the address PKH~P~, `1G5cycsCpe1ABLK41WTttnK1fo8ypYvocj`.
image::{imagedir}/skate-park-funding.svg[{half-width}]

Your neighbors don't have to know who else participates in the
funding. They effectively say "I'm, in only if enough others are.".

There are a few drawbacks with this method:

* Participants don't get any change back. They need to spend a whole UTXO.
* The PKH~P~ address is controlled by you, so your neighbors have to trust you not to run away with the money.


Open questions:

* Does anyone here know why the sequence of other inputs are zeroed when signing with SIGHASH_NONE or SIGHASH_SINGLE? Doesn't that interfere with relative lock time and RBF opt-in?

* Why do Bernanke outputs have values >0? Do they have to?

Closed questions:

* How can you make a relative lock-time transaction that is not opt-in RBF?
** opt-in is seq<0xffffffff-1 while rel-lock-time is 0x7fffffff-0x00000000

payment channel
lightning
